#summary This page, as the title implies, describes the architecture of NautilusSvn.
#labels Phase-Implementation

= Introduction =
In this page we'll look at what exactly a Nautilus extension is (the interface etc.) and dive into the NautilusSvn specifics.

The main concerns for NautilusSvn are:

  * Separation of actual version control logic and UI logic
    * Eventually we'll want to be able to support multiple version control systems, but at the moment we'll just focus on Subversion
  * Separation from the actual implementation (e.g. Nautilus, Thunar, Dolphin, PCManFM etc.)
  * Minimizing repetition (repeating statements, logic etc.)

= General =

== The basics of a Nautilus extension ==
NautilusSvn is a Nautilus extension written in Python using the [http://svn.gnome.org/viewvc/nautilus-python/trunk/ Python bindings for the Nautilus extension library] (nautilus-python in short). For an extensive introduction see [http://www.campd.org/stuff/docs/extending-nautilus/NautilusExtensions.html Nautilus Extensions].

A Nautilus extension can implement a couple of providers (interfaces), namely: 

  * NautilusInfoProvider: Information providers are used to add data to a NautilusFileInfo object and keep it up to date.
  * NautilusColumnProvider: Column providers add information to display in the list and icon views.
  * NautilusMenuProvider: Menu providers add menu items. Menu items can be added in three places: Per-file (shown in the file's context menu and the Edit menu), per-folder (shown in the background context menu and the File menu), and the toolbar.
  * NautilusPropertyPageProvider: Property providers add a property page to the file properties dialog.

Each of these providers come with their own set of functions one has to implement which in turn Nautilus will call to get 'things done'. We'll take a look specifically at NautilusInfoProvider.

== NautilusInfoProvider ==
When implementing the NautilusInfoProvider interface one has to implement the update_file_info function. 

  * TODO: write something about when update_file_info is exactly called and the relation with invalidate_extension_info on a GnomeVFSFileInfo. 

= Specifics =

= Directory structure =

A list of projects to borrow ideas from: [http://dev.deluge-torrent.org/browser/trunk Deluge], [http://pida.co.uk/trac/browser PIDA], [http://www.exaile.org/downloads Exaile], [http://musicbrainz.org/doc/PicardDownload MusicBrainz Picard] and [http://svn.gnome.org/viewvc/gnome-games/trunk/gnome-sudoku/ GNOME Sudoku] (also [http://svn.gnome.org/viewvc/nautilus/trunk/ Nautilus Actions] and [http://svn.gnome.org/viewvc/nautilus/trunk/ Nautilus])

Here's a possible directory structure to keep the files organized:

{{{
|-- COPYING
|-- README
|-- nautilussvn
|   |-- data
|   |   `-- icons
|   |-- docs
|   |-- lib
|   |   |-- extensions
|   |   |   `-- nautilus
|   |   `-- vcs
|   |       `-- svn.py
|   |-- po
|   |-- tests
|   `-- ui
|       `-- glade
|       `-- component
|-- packages
}}}

  _generated using the tree command_

_`__init__.py files left out for clarity`_

== Directory structure ==
The annoted tree below shows the most important directories (packages basically).

{{{

nautilussvn
|-- lib
|   |-- dbus             # our DBus services live here, mostly to interface with the StatusMonitor
|   |-- extensions       # the actual Nautilus extension code lives here so NautilusSvn and MainContextMenu
|   |-- settings.py      # our settings back-end
|   `-- vcs              # Our VCS specific code, also includes the StatusMonitor
`-- ui                   # the entire UI layer lives here (everything)
}}}

== High level ==

=== Modularity ===
  _How will we achieve the separation (loose coupling) we want?_

=== Abstracting the specific VCS (version control) implementation ===
I think we'll be able to abstract the VCS implementation by implementing the factory pattern. Then in the extension itself we'll be working against an interface. Here are some UML diagrams that model the factory pattern: 

  * `http://www.vico.org/pages/PatronsDisseny/Pattern%20Abstract%20Factory/AbstractFactory.jpg`
  * `http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/images/FactoryMethod.jpg` 
  * `http://www.dotnetheaven.com/Uploadfile/rajeshvs/AbstractFactoryPatternsinCS02012006041329AM/Images/AbstractFactPat.gif`.

There's also a page with [http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/ simple examples of several patterns from the GoF book in Python] (including the factory pattern).

== Components ==

=== Status cache ===

Take the entire TortoiseSVN working copy for example (which has 6,015 items). Without a status cache an initial recursive status check using PySVN would take 4393.7271 milliseconds (4 seconds) and consecutive status checks would take 917.6600 milliseconds (around a second). An initial status check with the status cache enabled takes longer because the way the cache is build but consecutive status checks take a mere 0.0069 milliseconds. You also have to add another 4 seconds or so because we have to recursively add watches.

== Frequently Asked Questions (FAQ) ==
=== Why do you use DBus? ===

Mostly a workaround for not being able to use threads from within a Nautilus extension (see source code). Don't ask us why, we don't know. 
#summary This page, as the title implies, describes the architecture of NautilusSvn.
#labels Phase-Design

= Overall architecture =

[http://nautilussvn.googlecode.com/svn/wiki/images/architecture/overall_architecture.png]

= Components =

== Extension =

`[..]`

== GUI ==

`[..]`

== D-Bus Service ==

=== Status Monitor ===

The only way to have the status for items stay up-to-date is by monitoring all items within a working copy and the related metadata (contained in the working copy administration areas, the .svn directories). The mechanism used to actually monitor the working copies is gio.GFileMonitor.

Upon encountering a working copy for the first time a recursive status check is done to build the status tree for that working copy. The status monitor will watch for any changes to all files/directories and the .svn/entries file (which is the only file modified when doing SVN operations) and modify the status tree accordingly. 

Say you have a directory /foo containing bar and baz and you then svn add bar and modify baz. This results in changes for /foo/bar and /foo/.svn/entries. If we could figure out by comparing the previous entries file what item was modified we could then add /foo/bar and /foo/baz to the queue for later processing (to prevent too many checks from being done and conflicting). 

Then when the status monitor returns to an idle state the queue is processed, status checks are done for /foo/bar and /foo/baz and their status in the tree is updated accordingly, the parent directories will then update their own status based on any children in the tree.

=== Cache ===

`[..]`

== VCS Abstraction Layer ==

`[..]`

= Unsorted =

  * Skipping intensive operations while on battery power may be a good idea.

  * It may well be possible to do some magic and determine the status of a particular item without having to do an svn status check, but this looks really hard.

  * I wonder if it's possible to analyze the .svn/entries file to determine precisely what files were modified.